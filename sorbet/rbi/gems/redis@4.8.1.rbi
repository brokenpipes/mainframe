# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `redis` gem.
# Please instead update this file by running `bin/tapioca gem redis`.

# source://redis//lib/redis/errors.rb#3
class Redis
  include ::Redis::Commands::Bitmaps
  include ::Redis::Commands::Cluster
  include ::Redis::Commands::Connection
  include ::Redis::Commands::Geo
  include ::Redis::Commands::Hashes
  include ::Redis::Commands::HyperLogLog
  include ::Redis::Commands::Keys
  include ::Redis::Commands::Lists
  include ::Redis::Commands::Pubsub
  include ::Redis::Commands::Scripting
  include ::Redis::Commands::Server
  include ::Redis::Commands::Sets
  include ::Redis::Commands::SortedSets
  include ::Redis::Commands::Streams
  include ::Redis::Commands::Strings
  include ::Redis::Commands::Transactions
  include ::Redis::Commands

  # source://redis//lib/redis.rb#83
  def initialize(options = T.unsafe(nil)); end

  # source://redis//lib/redis.rb#160
  def _client; end

  # source://redis//lib/redis.rb#110
  def close; end

  # source://redis//lib/redis.rb#140
  def commit; end

  # source://redis//lib/redis.rb#105
  def connected?; end

  # source://redis//lib/redis.rb#250
  def connection; end

  # source://redis//lib/redis.rb#110
  def disconnect!; end

  # source://redis//lib/redis.rb#246
  def dup; end

  # source://redis//lib/redis.rb#238
  def id; end

  # source://redis//lib/redis.rb#242
  def inspect; end

  # source://redis//lib/redis.rb#214
  def multi(&block); end

  # source://redis//lib/redis.rb#164
  def pipelined(&block); end

  # source://redis//lib/redis.rb#125
  def queue(*command); end

  # source://redis//lib/redis.rb#115
  def with; end

  # source://redis//lib/redis.rb#93
  def with_reconnect(val = T.unsafe(nil), &blk); end

  # source://redis//lib/redis.rb#100
  def without_reconnect(&blk); end

  private

  # source://redis//lib/redis.rb#280
  def _subscription(method, timeout, channels, block); end

  # source://redis//lib/redis.rb#274
  def send_blocking_command(command, timeout, &block); end

  # source://redis//lib/redis.rb#268
  def send_command(command, &block); end

  # source://redis//lib/redis.rb#264
  def synchronize; end

  class << self
    # source://redis//lib/redis.rb#40
    def current; end

    # source://redis//lib/redis.rb#45
    def current=(redis); end

    # source://redis//lib/redis.rb#30
    def deprecate!(message); end

    # source://redis//lib/redis.rb#15
    def exists_returns_integer; end

    # source://redis//lib/redis.rb#18
    def exists_returns_integer=(value); end

    # source://redis//lib/redis.rb#16
    def raise_deprecations; end

    # source://redis//lib/redis.rb#16
    def raise_deprecations=(_arg0); end

    # source://redis//lib/redis.rb#16
    def sadd_returns_boolean; end

    # source://redis//lib/redis.rb#16
    def sadd_returns_boolean=(_arg0); end

    # source://redis//lib/redis.rb#16
    def silence_deprecations; end

    # source://redis//lib/redis.rb#16
    def silence_deprecations=(_arg0); end
  end
end

# source://redis//lib/redis.rb#8
Redis::BASE_PATH = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/errors.rb#24
class Redis::BaseConnectionError < ::Redis::BaseError; end

# source://redis//lib/redis/errors.rb#5
class Redis::BaseError < ::RuntimeError; end

# source://redis//lib/redis/errors.rb#28
class Redis::CannotConnectError < ::Redis::BaseConnectionError; end

# source://redis//lib/redis/client.rb#8
class Redis::Client
  # source://redis//lib/redis/client.rb#91
  def initialize(options = T.unsafe(nil)); end

  # source://redis//lib/redis/client.rb#160
  def call(command); end

  # source://redis//lib/redis/client.rb#171
  def call_loop(command, timeout = T.unsafe(nil)); end

  # source://redis//lib/redis/client.rb#195
  def call_pipeline(pipeline); end

  # source://redis//lib/redis/client.rb#214
  def call_pipelined(pipeline); end

  # source://redis//lib/redis/client.rb#254
  def call_with_timeout(command, extra_timeout, &blk); end

  # source://redis//lib/redis/client.rb#263
  def call_without_timeout(command, &blk); end

  # source://redis//lib/redis/client.rb#288
  def close; end

  # source://redis//lib/redis/client.rb#35
  def command_map; end

  # source://redis//lib/redis/client.rb#110
  def connect; end

  # source://redis//lib/redis/client.rb#57
  def connect_timeout; end

  # source://redis//lib/redis/client.rb#284
  def connected?; end

  # source://redis//lib/redis/client.rb#35
  def connection; end

  # source://redis//lib/redis/client.rb#73
  def db; end

  # source://redis//lib/redis/client.rb#77
  def db=(db); end

  # source://redis//lib/redis/client.rb#288
  def disconnect; end

  # source://redis//lib/redis/client.rb#81
  def driver; end

  # source://redis//lib/redis/client.rb#41
  def host; end

  # source://redis//lib/redis/client.rb#152
  def id; end

  # source://redis//lib/redis/client.rb#85
  def inherit_socket?; end

  # source://redis//lib/redis/client.rb#298
  def io; end

  # source://redis//lib/redis/client.rb#156
  def location; end

  # source://redis//lib/redis/client.rb#89
  def logger; end

  # source://redis//lib/redis/client.rb#89
  def logger=(_arg0); end

  # source://redis//lib/redis/client.rb#35
  def options; end

  # source://redis//lib/redis/client.rb#69
  def password; end

  # source://redis//lib/redis/client.rb#49
  def path; end

  # source://redis//lib/redis/client.rb#45
  def port; end

  # source://redis//lib/redis/client.rb#267
  def process(commands); end

  # source://redis//lib/redis/client.rb#309
  def read; end

  # source://redis//lib/redis/client.rb#53
  def read_timeout; end

  # source://redis//lib/redis/client.rb#293
  def reconnect; end

  # source://redis//lib/redis/client.rb#37
  def scheme; end

  # source://redis//lib/redis/client.rb#61
  def timeout; end

  # source://redis//lib/redis/client.rb#65
  def username; end

  # source://redis//lib/redis/client.rb#342
  def with_reconnect(val = T.unsafe(nil)); end

  # source://redis//lib/redis/client.rb#324
  def with_socket_timeout(timeout); end

  # source://redis//lib/redis/client.rb#349
  def without_reconnect(&blk); end

  # source://redis//lib/redis/client.rb#338
  def without_socket_timeout(&blk); end

  # source://redis//lib/redis/client.rb#317
  def write(command); end

  protected

  # source://redis//lib/redis/client.rb#529
  def _parse_driver(driver); end

  # source://redis//lib/redis/client.rb#430
  def _parse_options(options); end

  # source://redis//lib/redis/client.rb#401
  def ensure_connected; end

  # source://redis//lib/redis/client.rb#379
  def establish_connection; end

  # source://redis//lib/redis/client.rb#355
  def logging(commands); end
end

# source://redis//lib/redis/client.rb#549
class Redis::Client::Connector
  # source://redis//lib/redis/client.rb#550
  def initialize(options); end

  # source://redis//lib/redis/client.rb#558
  def check(client); end

  # source://redis//lib/redis/client.rb#554
  def resolve; end
end

# source://redis//lib/redis/client.rb#560
class Redis::Client::Connector::Sentinel < ::Redis::Client::Connector
  # source://redis//lib/redis/client.rb#561
  def initialize(options); end

  # source://redis//lib/redis/client.rb#571
  def check(client); end

  # source://redis//lib/redis/client.rb#588
  def resolve; end

  # source://redis//lib/redis/client.rb#628
  def resolve_master; end

  # source://redis//lib/redis/client.rb#636
  def resolve_slave; end

  # source://redis//lib/redis/client.rb#601
  def sentinel_detect; end
end

# source://redis//lib/redis/client.rb#10
Redis::Client::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://redis//lib/redis/errors.rb#47
class Redis::Cluster
  # source://redis//lib/redis/cluster.rb#24
  def initialize(options = T.unsafe(nil)); end

  # source://redis//lib/redis/cluster.rb#71
  def call(command, &block); end

  # source://redis//lib/redis/cluster.rb#75
  def call_loop(command, timeout = T.unsafe(nil), &block); end

  # source://redis//lib/redis/cluster.rb#80
  def call_pipeline(pipeline); end

  # source://redis//lib/redis/cluster.rb#90
  def call_with_timeout(command, timeout, &block); end

  # source://redis//lib/redis/cluster.rb#95
  def call_without_timeout(command, &block); end

  # source://redis//lib/redis/cluster.rb#46
  def connected?; end

  # source://redis//lib/redis/cluster.rb#55
  def connection_info; end

  # source://redis//lib/redis/cluster.rb#35
  def db; end

  # source://redis//lib/redis/cluster.rb#40
  def db=(_db); end

  # source://redis//lib/redis/cluster.rb#50
  def disconnect; end

  # source://redis//lib/redis/cluster.rb#30
  def id; end

  # source://redis//lib/redis/cluster.rb#99
  def process(commands, &block); end

  # source://redis//lib/redis/cluster.rb#42
  def timeout; end

  # source://redis//lib/redis/cluster.rb#67
  def with_reconnect(val = T.unsafe(nil), &block); end

  private

  # source://redis//lib/redis/cluster.rb#242
  def _scan(command, &block); end

  # source://redis//lib/redis/cluster.rb#272
  def assign_asking_node(err_msg); end

  # source://redis//lib/redis/cluster.rb#277
  def assign_node(command); end

  # source://redis//lib/redis/cluster.rb#265
  def assign_redirection_node(err_msg); end

  # source://redis//lib/redis/cluster.rb#114
  def fetch_cluster_info!(option); end

  # source://redis//lib/redis/cluster.rb#125
  def fetch_command_details(nodes); end

  # source://redis//lib/redis/cluster.rb#296
  def find_node(node_key); end

  # source://redis//lib/redis/cluster.rb#282
  def find_node_key(command, primary_only: T.unsafe(nil)); end

  # source://redis//lib/redis/cluster.rb#175
  def send_client_command(command, &block); end

  # source://redis//lib/redis/cluster.rb#184
  def send_cluster_command(command, &block); end

  # source://redis//lib/redis/cluster.rb#130
  def send_command(command, &block); end

  # source://redis//lib/redis/cluster.rb#159
  def send_config_command(command, &block); end

  # source://redis//lib/redis/cluster.rb#167
  def send_memory_command(command, &block); end

  # source://redis//lib/redis/cluster.rb#205
  def send_pubsub_command(command, &block); end

  # source://redis//lib/redis/cluster.rb#195
  def send_script_command(command, &block); end

  # source://redis//lib/redis/cluster.rb#218
  def try_send(node, method_name, *args, retry_count: T.unsafe(nil), &block); end

  # source://redis//lib/redis/cluster.rb#305
  def update_cluster_info!(node_key = T.unsafe(nil)); end
end

# source://redis//lib/redis/errors.rb#83
class Redis::Cluster::AmbiguousNodeError < ::Redis::BaseError
  # source://redis//lib/redis/errors.rb#84
  def initialize(command); end
end

# source://redis//lib/redis/cluster/command.rb#9
class Redis::Cluster::Command
  # source://redis//lib/redis/cluster/command.rb#10
  def initialize(details); end

  # source://redis//lib/redis/cluster/command.rb#14
  def extract_first_key(command); end

  # source://redis//lib/redis/cluster/command.rb#23
  def should_send_to_master?(command); end

  # source://redis//lib/redis/cluster/command.rb#27
  def should_send_to_slave?(command); end

  private

  # source://redis//lib/redis/cluster/command.rb#50
  def determine_first_key_position(command); end

  # source://redis//lib/redis/cluster/command.rb#63
  def determine_optional_key_position(command, option_name); end

  # source://redis//lib/redis/cluster/command.rb#43
  def dig_details(command, key); end

  # source://redis//lib/redis/cluster/command.rb#69
  def extract_hash_tag(key); end

  # source://redis//lib/redis/cluster/command.rb#33
  def pick_details(details); end
end

# source://redis//lib/redis/errors.rb#71
class Redis::Cluster::CommandErrorCollection < ::Redis::BaseError
  # source://redis//lib/redis/errors.rb#76
  def initialize(errors, error_message = T.unsafe(nil)); end

  # source://redis//lib/redis/errors.rb#72
  def errors; end
end

# source://redis//lib/redis/cluster/command_loader.rb#9
module Redis::Cluster::CommandLoader
  private

  # source://redis//lib/redis/cluster/command_loader.rb#24
  def fetch_command_details(node); end

  # source://redis//lib/redis/cluster/command_loader.rb#12
  def load(nodes); end

  class << self
    # source://redis//lib/redis/cluster/command_loader.rb#12
    def load(nodes); end

    private

    # source://redis//lib/redis/cluster/command_loader.rb#24
    def fetch_command_details(node); end
  end
end

# source://redis//lib/redis/errors.rb#90
class Redis::Cluster::CrossSlotPipeliningError < ::Redis::BaseError
  # source://redis//lib/redis/errors.rb#91
  def initialize(keys); end
end

# source://redis//lib/redis/errors.rb#50
class Redis::Cluster::InitialSetupError < ::Redis::BaseError
  # source://redis//lib/redis/errors.rb#52
  def initialize(errors); end
end

# source://redis//lib/redis/cluster/key_slot_converter.rb#17
module Redis::Cluster::KeySlotConverter
  private

  # source://redis//lib/redis/cluster/key_slot_converter.rb#62
  def convert(key); end

  class << self
    # source://redis//lib/redis/cluster/key_slot_converter.rb#62
    def convert(key); end
  end
end

# source://redis//lib/redis/cluster/key_slot_converter.rb#53
Redis::Cluster::KeySlotConverter::HASH_SLOTS = T.let(T.unsafe(nil), Integer)

# source://redis//lib/redis/cluster/key_slot_converter.rb#18
Redis::Cluster::KeySlotConverter::XMODEM_CRC16_LOOKUP = T.let(T.unsafe(nil), Array)

# source://redis//lib/redis/cluster/node.rb#8
class Redis::Cluster::Node
  include ::Enumerable

  # source://redis//lib/redis/cluster/node.rb#15
  def initialize(options, node_flags = T.unsafe(nil), with_replica = T.unsafe(nil)); end

  # source://redis//lib/redis/cluster/node.rb#35
  def call_all(command, &block); end

  # source://redis//lib/redis/cluster/node.rb#39
  def call_master(command, &block); end

  # source://redis//lib/redis/cluster/node.rb#47
  def call_slave(command, &block); end

  # source://redis//lib/redis/cluster/node.rb#21
  def each(&block); end

  # source://redis//lib/redis/cluster/node.rb#29
  def find_by(node_key); end

  # source://redis//lib/redis/cluster/node.rb#57
  def process_all(commands, &block); end

  # source://redis//lib/redis/cluster/node.rb#25
  def sample; end

  # source://redis//lib/redis/cluster/node.rb#61
  def scale_reading_clients; end

  private

  # source://redis//lib/redis/cluster/node.rb#87
  def build_clients(options); end

  # source://redis//lib/redis/cluster/node.rb#79
  def master?(node_key); end

  # source://redis//lib/redis/cluster/node.rb#75
  def replica_disabled?; end

  # source://redis//lib/redis/cluster/node.rb#83
  def slave?(node_key); end

  # source://redis//lib/redis/cluster/node.rb#100
  def try_map; end
end

# source://redis//lib/redis/cluster/node.rb#13
Redis::Cluster::Node::ROLE_SLAVE = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/cluster/node.rb#11
class Redis::Cluster::Node::ReloadNeeded < ::StandardError; end

# source://redis//lib/redis/cluster/node_key.rb#8
module Redis::Cluster::NodeKey
  private

  # source://redis//lib/redis/cluster/node_key.rb#26
  def build_from_host_port(host, port); end

  # source://redis//lib/redis/cluster/node_key.rb#22
  def build_from_uri(uri); end

  # source://redis//lib/redis/cluster/node_key.rb#13
  def optionize(node_key); end

  # source://redis//lib/redis/cluster/node_key.rb#18
  def split(node_key); end

  class << self
    # source://redis//lib/redis/cluster/node_key.rb#26
    def build_from_host_port(host, port); end

    # source://redis//lib/redis/cluster/node_key.rb#22
    def build_from_uri(uri); end

    # source://redis//lib/redis/cluster/node_key.rb#13
    def optionize(node_key); end

    # source://redis//lib/redis/cluster/node_key.rb#18
    def split(node_key); end
  end
end

# source://redis//lib/redis/cluster/node_key.rb#9
Redis::Cluster::NodeKey::DELIMITER = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/cluster/node_loader.rb#8
module Redis::Cluster::NodeLoader
  private

  # source://redis//lib/redis/cluster/node_loader.rb#23
  def fetch_node_info(node); end

  # source://redis//lib/redis/cluster/node_loader.rb#11
  def load_flags(nodes); end

  class << self
    # source://redis//lib/redis/cluster/node_loader.rb#11
    def load_flags(nodes); end

    private

    # source://redis//lib/redis/cluster/node_loader.rb#23
    def fetch_node_info(node); end
  end
end

# source://redis//lib/redis/cluster/option.rb#10
class Redis::Cluster::Option
  # source://redis//lib/redis/cluster/option.rb#15
  def initialize(options); end

  # source://redis//lib/redis/cluster/option.rb#44
  def add_node(host, port); end

  # source://redis//lib/redis/cluster/option.rb#27
  def per_node_key; end

  # source://redis//lib/redis/cluster/option.rb#40
  def update_node(addrs); end

  # source://redis//lib/redis/cluster/option.rb#36
  def use_replica?; end

  private

  # source://redis//lib/redis/cluster/option.rb#93
  def add_common_node_option_if_needed(options, node_opts, key); end

  # source://redis//lib/redis/cluster/option.rb#50
  def build_node_options(addrs); end

  # source://redis//lib/redis/cluster/option.rb#56
  def parse_node_addr(addr); end

  # source://redis//lib/redis/cluster/option.rb#81
  def parse_node_option(addr); end

  # source://redis//lib/redis/cluster/option.rb#67
  def parse_node_url(addr); end
end

# source://redis//lib/redis/cluster/option.rb#11
Redis::Cluster::Option::DEFAULT_SCHEME = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/cluster/option.rb#12
Redis::Cluster::Option::SECURE_SCHEME = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/cluster/option.rb#13
Redis::Cluster::Option::VALID_SCHEMES = T.let(T.unsafe(nil), Array)

# source://redis//lib/redis/errors.rb#59
class Redis::Cluster::OrchestrationCommandNotSupported < ::Redis::BaseError
  # source://redis//lib/redis/errors.rb#60
  def initialize(command, subcommand = T.unsafe(nil)); end
end

# source://redis//lib/redis/cluster/slot.rb#6
class Redis::Cluster::Slot
  # source://redis//lib/redis/cluster/slot.rb#9
  def initialize(available_slots, node_flags = T.unsafe(nil), with_replica = T.unsafe(nil)); end

  # source://redis//lib/redis/cluster/slot.rb#15
  def exists?(slot); end

  # source://redis//lib/redis/cluster/slot.rb#19
  def find_node_key_of_master(slot); end

  # source://redis//lib/redis/cluster/slot.rb#25
  def find_node_key_of_slave(slot); end

  # source://redis//lib/redis/cluster/slot.rb#32
  def put(slot, node_key); end

  private

  # source://redis//lib/redis/cluster/slot.rb#61
  def build_slot_node_key_map(available_slots); end

  # source://redis//lib/redis/cluster/slot.rb#52
  def master?(node_key); end

  # source://redis//lib/redis/cluster/slot.rb#48
  def replica_disabled?; end

  # source://redis//lib/redis/cluster/slot.rb#56
  def slave?(node_key); end
end

# source://redis//lib/redis/cluster/slot.rb#7
Redis::Cluster::Slot::ROLE_SLAVE = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/cluster/slot_loader.rb#9
module Redis::Cluster::SlotLoader
  private

  # source://redis//lib/redis/cluster/slot_loader.rb#24
  def fetch_slot_info(node); end

  # source://redis//lib/redis/cluster/slot_loader.rb#12
  def load(nodes); end

  # source://redis//lib/redis/cluster/slot_loader.rb#31
  def parse_slot_info(arr, default_ip:); end

  # source://redis//lib/redis/cluster/slot_loader.rb#37
  def stringify_node_key(arr, default_ip); end

  class << self
    # source://redis//lib/redis/cluster/slot_loader.rb#12
    def load(nodes); end

    private

    # source://redis//lib/redis/cluster/slot_loader.rb#24
    def fetch_slot_info(node); end

    # source://redis//lib/redis/cluster/slot_loader.rb#31
    def parse_slot_info(arr, default_ip:); end

    # source://redis//lib/redis/cluster/slot_loader.rb#37
    def stringify_node_key(arr, default_ip); end
  end
end

# source://redis//lib/redis/errors.rb#20
class Redis::CommandError < ::Redis::BaseError; end

# source://redis//lib/redis/commands/bitmaps.rb#4
module Redis::Commands
  include ::Redis::Commands::Bitmaps
  include ::Redis::Commands::Cluster
  include ::Redis::Commands::Connection
  include ::Redis::Commands::Geo
  include ::Redis::Commands::Hashes
  include ::Redis::Commands::HyperLogLog
  include ::Redis::Commands::Keys
  include ::Redis::Commands::Lists
  include ::Redis::Commands::Pubsub
  include ::Redis::Commands::Scripting
  include ::Redis::Commands::Server
  include ::Redis::Commands::Sets
  include ::Redis::Commands::SortedSets
  include ::Redis::Commands::Streams
  include ::Redis::Commands::Strings
  include ::Redis::Commands::Transactions

  # source://redis//lib/redis/commands.rb#205
  def call(*command); end

  # source://redis//lib/redis/commands.rb#214
  def sentinel(subcommand, *args); end

  private

  # source://redis//lib/redis/commands.rb#236
  def method_missing(*command); end
end

# source://redis//lib/redis/commands/bitmaps.rb#5
module Redis::Commands::Bitmaps
  # source://redis//lib/redis/commands/bitmaps.rb#31
  def bitcount(key, start = T.unsafe(nil), stop = T.unsafe(nil)); end

  # source://redis//lib/redis/commands/bitmaps.rb#41
  def bitop(operation, destkey, *keys); end

  # source://redis//lib/redis/commands/bitmaps.rb#53
  def bitpos(key, bit, start = T.unsafe(nil), stop = T.unsafe(nil)); end

  # source://redis//lib/redis/commands/bitmaps.rb#21
  def getbit(key, offset); end

  # source://redis//lib/redis/commands/bitmaps.rb#12
  def setbit(key, offset, value); end
end

# source://redis//lib/redis/commands.rb#42
Redis::Commands::Boolify = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands.rb#51
Redis::Commands::BoolifySet = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands/cluster.rb#5
module Redis::Commands::Cluster
  # source://redis//lib/redis/commands/cluster.rb#40
  def asking; end

  # source://redis//lib/redis/commands/cluster.rb#14
  def cluster(subcommand, *args); end
end

# source://redis//lib/redis/commands/connection.rb#5
module Redis::Commands::Connection
  # source://redis//lib/redis/commands/connection.rb#12
  def auth(*args); end

  # source://redis//lib/redis/commands/connection.rb#28
  def echo(value); end

  # source://redis//lib/redis/commands/connection.rb#20
  def ping(message = T.unsafe(nil)); end

  # source://redis//lib/redis/commands/connection.rb#46
  def quit; end

  # source://redis//lib/redis/commands/connection.rb#36
  def select(db); end
end

# source://redis//lib/redis/commands.rb#115
Redis::Commands::EMPTY_STREAM_RESPONSE = T.let(T.unsafe(nil), Array)

# source://redis//lib/redis/commands.rb#78
Redis::Commands::Floatify = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands.rb#91
Redis::Commands::FloatifyPairs = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands/geo.rb#5
module Redis::Commands::Geo
  # source://redis//lib/redis/commands/geo.rb#11
  def geoadd(key, *member); end

  # source://redis//lib/redis/commands/geo.rb#70
  def geodist(key, member1, member2, unit = T.unsafe(nil)); end

  # source://redis//lib/redis/commands/geo.rb#20
  def geohash(key, member); end

  # source://redis//lib/redis/commands/geo.rb#60
  def geopos(key, member); end

  # source://redis//lib/redis/commands/geo.rb#33
  def georadius(*args, **geoptions); end

  # source://redis//lib/redis/commands/geo.rb#48
  def georadiusbymember(*args, **geoptions); end

  private

  # source://redis//lib/redis/commands/geo.rb#76
  def _geoarguments(*args, options: T.unsafe(nil), sort: T.unsafe(nil), count: T.unsafe(nil)); end
end

# source://redis//lib/redis/commands/hashes.rb#5
module Redis::Commands::Hashes
  # source://redis//lib/redis/commands/hashes.rb#154
  def hdel(key, *fields); end

  # source://redis//lib/redis/commands/hashes.rb#163
  def hexists(key, field); end

  # source://redis//lib/redis/commands/hashes.rb#74
  def hget(key, field); end

  # source://redis//lib/redis/commands/hashes.rb#207
  def hgetall(key); end

  # source://redis//lib/redis/commands/hashes.rb#173
  def hincrby(key, field, increment); end

  # source://redis//lib/redis/commands/hashes.rb#183
  def hincrbyfloat(key, field, increment); end

  # source://redis//lib/redis/commands/hashes.rb#191
  def hkeys(key); end

  # source://redis//lib/redis/commands/hashes.rb#10
  def hlen(key); end

  # source://redis//lib/redis/commands/hashes.rb#89
  def hmget(key, *fields, &blk); end

  # source://redis//lib/redis/commands/hashes.rb#50
  def hmset(key, *attrs); end

  # source://redis//lib/redis/commands/hashes.rb#136
  def hrandfield(key, count = T.unsafe(nil), withvalues: T.unsafe(nil), with_values: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/hashes.rb#222
  def hscan(key, cursor, **options); end

  # source://redis//lib/redis/commands/hashes.rb#239
  def hscan_each(key, **options, &block); end

  # source://redis//lib/redis/commands/hashes.rb#23
  def hset(key, *attrs); end

  # source://redis//lib/redis/commands/hashes.rb#35
  def hsetnx(key, field, value); end

  # source://redis//lib/redis/commands/hashes.rb#199
  def hvals(key); end

  # source://redis//lib/redis/commands/hashes.rb#104
  def mapped_hmget(key, *fields); end

  # source://redis//lib/redis/commands/hashes.rb#65
  def mapped_hmset(key, hash); end
end

# source://redis//lib/redis/commands.rb#62
Redis::Commands::Hashify = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands.rb#158
Redis::Commands::HashifyClusterNodeInfo = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands.rb#187
Redis::Commands::HashifyClusterNodes = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands.rb#191
Redis::Commands::HashifyClusterSlaves = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands.rb#173
Redis::Commands::HashifyClusterSlots = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands.rb#99
Redis::Commands::HashifyInfo = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands.rb#124
Redis::Commands::HashifyStreamAutoclaim = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands.rb#131
Redis::Commands::HashifyStreamAutoclaimJustId = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands.rb#118
Redis::Commands::HashifyStreamEntries = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands.rb#147
Redis::Commands::HashifyStreamPendingDetails = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands.rb#138
Redis::Commands::HashifyStreamPendings = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands.rb#106
Redis::Commands::HashifyStreams = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands/hyper_log_log.rb#5
module Redis::Commands::HyperLogLog
  # source://redis//lib/redis/commands/hyper_log_log.rb#11
  def pfadd(key, member); end

  # source://redis//lib/redis/commands/hyper_log_log.rb#22
  def pfcount(*keys); end

  # source://redis//lib/redis/commands/hyper_log_log.rb#32
  def pfmerge(dest_key, *source_key); end
end

# source://redis//lib/redis/commands/keys.rb#5
module Redis::Commands::Keys
  # source://redis//lib/redis/commands/keys.rb#269
  def _exists(*keys); end

  # source://redis//lib/redis/commands/keys.rb#345
  def copy(source, destination, db: T.unsafe(nil), replace: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/keys.rb#232
  def del(*keys); end

  # source://redis//lib/redis/commands/keys.rb#183
  def dump(key); end

  # source://redis//lib/redis/commands/keys.rb#251
  def exists(*keys); end

  # source://redis//lib/redis/commands/keys.rb#277
  def exists?(*keys); end

  # source://redis//lib/redis/commands/keys.rb#78
  def expire(key, seconds, nx: T.unsafe(nil), xx: T.unsafe(nil), gt: T.unsafe(nil), lt: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/keys.rb#98
  def expireat(key, unix_time, nx: T.unsafe(nil), xx: T.unsafe(nil), gt: T.unsafe(nil), lt: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/keys.rb#287
  def keys(pattern = T.unsafe(nil)); end

  # source://redis//lib/redis/commands/keys.rb#214
  def migrate(key, options); end

  # source://redis//lib/redis/commands/keys.rb#316
  def move(key, db); end

  # source://redis//lib/redis/commands/keys.rb#353
  def object(*args); end

  # source://redis//lib/redis/commands/keys.rb#64
  def persist(key); end

  # source://redis//lib/redis/commands/keys.rb#134
  def pexpire(key, milliseconds, nx: T.unsafe(nil), xx: T.unsafe(nil), gt: T.unsafe(nil), lt: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/keys.rb#154
  def pexpireat(key, ms_unix_time, nx: T.unsafe(nil), xx: T.unsafe(nil), gt: T.unsafe(nil), lt: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/keys.rb#175
  def pttl(key); end

  # source://redis//lib/redis/commands/keys.rb#360
  def randomkey; end

  # source://redis//lib/redis/commands/keys.rb#369
  def rename(old_name, new_name); end

  # source://redis//lib/redis/commands/keys.rb#378
  def renamenx(old_name, new_name); end

  # source://redis//lib/redis/commands/keys.rb#196
  def restore(key, ttl, serialized_value, replace: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/keys.rb#25
  def scan(cursor, **options); end

  # source://redis//lib/redis/commands/keys.rb#49
  def scan_each(**options, &block); end

  # source://redis//lib/redis/commands/keys.rb#407
  def sort(key, by: T.unsafe(nil), limit: T.unsafe(nil), get: T.unsafe(nil), order: T.unsafe(nil), store: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/keys.rb#120
  def ttl(key); end

  # source://redis//lib/redis/commands/keys.rb#437
  def type(key); end

  # source://redis//lib/redis/commands/keys.rb#243
  def unlink(*keys); end

  private

  # source://redis//lib/redis/commands/keys.rb#443
  def _scan(command, cursor, args, match: T.unsafe(nil), count: T.unsafe(nil), type: T.unsafe(nil), &block); end
end

# source://redis//lib/redis/commands/lists.rb#5
module Redis::Commands::Lists
  # source://redis//lib/redis/commands/lists.rb#55
  def blmove(source, destination, where_source, where_destination, timeout: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/lists.rb#150
  def blpop(*args); end

  # source://redis//lib/redis/commands/lists.rb#166
  def brpop(*args); end

  # source://redis//lib/redis/commands/lists.rb#181
  def brpoplpush(source, destination, deprecated_timeout = T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/lists.rb#191
  def lindex(key, index); end

  # source://redis//lib/redis/commands/lists.rb#203
  def linsert(key, where, pivot, value); end

  # source://redis//lib/redis/commands/lists.rb#10
  def llen(key); end

  # source://redis//lib/redis/commands/lists.rb#27
  def lmove(source, destination, where_source, where_destination); end

  # source://redis//lib/redis/commands/lists.rb#103
  def lpop(key, count = T.unsafe(nil)); end

  # source://redis//lib/redis/commands/lists.rb#67
  def lpush(key, value); end

  # source://redis//lib/redis/commands/lists.rb#76
  def lpushx(key, value); end

  # source://redis//lib/redis/commands/lists.rb#213
  def lrange(key, start, stop); end

  # source://redis//lib/redis/commands/lists.rb#226
  def lrem(key, count, value); end

  # source://redis//lib/redis/commands/lists.rb#236
  def lset(key, index, value); end

  # source://redis//lib/redis/commands/lists.rb#246
  def ltrim(key, start, stop); end

  # source://redis//lib/redis/commands/lists.rb#114
  def rpop(key, count = T.unsafe(nil)); end

  # source://redis//lib/redis/commands/lists.rb#125
  def rpoplpush(source, destination); end

  # source://redis//lib/redis/commands/lists.rb#85
  def rpush(key, value); end

  # source://redis//lib/redis/commands/lists.rb#94
  def rpushx(key, value); end

  private

  # source://redis//lib/redis/commands/lists.rb#252
  def _bpop(cmd, args, &blk); end

  # source://redis//lib/redis/commands/lists.rb#274
  def _normalize_move_wheres(where_source, where_destination); end
end

# source://redis//lib/redis/commands.rb#195
Redis::Commands::Noop = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands.rb#70
Redis::Commands::Pairify = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis/commands/pubsub.rb#5
module Redis::Commands::Pubsub
  # source://redis//lib/redis/commands/pubsub.rb#42
  def psubscribe(*channels, &block); end

  # source://redis//lib/redis/commands/pubsub.rb#50
  def psubscribe_with_timeout(timeout, *channels, &block); end

  # source://redis//lib/redis/commands/pubsub.rb#7
  def publish(channel, message); end

  # source://redis//lib/redis/commands/pubsub.rb#67
  def pubsub(subcommand, *args); end

  # source://redis//lib/redis/commands/pubsub.rb#57
  def punsubscribe(*channels); end

  # source://redis//lib/redis/commands/pubsub.rb#18
  def subscribe(*channels, &block); end

  # source://redis//lib/redis/commands/pubsub.rb#26
  def subscribe_with_timeout(timeout, *channels, &block); end

  # source://redis//lib/redis/commands/pubsub.rb#11
  def subscribed?; end

  # source://redis//lib/redis/commands/pubsub.rb#33
  def unsubscribe(*channels); end
end

# source://redis//lib/redis/commands/scripting.rb#5
module Redis::Commands::Scripting
  # source://redis//lib/redis/commands/scripting.rb#71
  def eval(*args); end

  # source://redis//lib/redis/commands/scripting.rb#96
  def evalsha(*args); end

  # source://redis//lib/redis/commands/scripting.rb#30
  def script(subcommand, *args); end

  private

  # source://redis//lib/redis/commands/scripting.rb#102
  def _eval(cmd, args); end
end

# source://redis//lib/redis/commands/server.rb#5
module Redis::Commands::Server
  # source://redis//lib/redis/commands/server.rb#9
  def bgrewriteaof; end

  # source://redis//lib/redis/commands/server.rb#16
  def bgsave; end

  # source://redis//lib/redis/commands/server.rb#39
  def client(subcommand = T.unsafe(nil), *args); end

  # source://redis//lib/redis/commands/server.rb#25
  def config(action, *args); end

  # source://redis//lib/redis/commands/server.rb#55
  def dbsize; end

  # source://redis//lib/redis/commands/server.rb#183
  def debug(*args); end

  # source://redis//lib/redis/commands/server.rb#64
  def flushall(options = T.unsafe(nil)); end

  # source://redis//lib/redis/commands/server.rb#77
  def flushdb(options = T.unsafe(nil)); end

  # source://redis//lib/redis/commands/server.rb#89
  def info(cmd = T.unsafe(nil)); end

  # source://redis//lib/redis/commands/server.rb#110
  def lastsave; end

  # source://redis//lib/redis/commands/server.rb#120
  def monitor(&block); end

  # source://redis//lib/redis/commands/server.rb#129
  def save; end

  # source://redis//lib/redis/commands/server.rb#134
  def shutdown; end

  # source://redis//lib/redis/commands/server.rb#148
  def slaveof(host, port); end

  # source://redis//lib/redis/commands/server.rb#157
  def slowlog(subcommand, length = T.unsafe(nil)); end

  # source://redis//lib/redis/commands/server.rb#166
  def sync; end

  # source://redis//lib/redis/commands/server.rb#177
  def time; end
end

# source://redis//lib/redis/commands/sets.rb#5
module Redis::Commands::Sets
  # source://redis//lib/redis/commands/sets.rb#22
  def sadd(key, member); end

  # source://redis//lib/redis/commands/sets.rb#38
  def sadd?(key, member); end

  # source://redis//lib/redis/commands/sets.rb#10
  def scard(key); end

  # source://redis//lib/redis/commands/sets.rb#138
  def sdiff(*keys); end

  # source://redis//lib/redis/commands/sets.rb#147
  def sdiffstore(destination, *keys); end

  # source://redis//lib/redis/commands/sets.rb#155
  def sinter(*keys); end

  # source://redis//lib/redis/commands/sets.rb#164
  def sinterstore(destination, *keys); end

  # source://redis//lib/redis/commands/sets.rb#111
  def sismember(key, member); end

  # source://redis//lib/redis/commands/sets.rb#130
  def smembers(key); end

  # source://redis//lib/redis/commands/sets.rb#120
  def smismember(key, *members); end

  # source://redis//lib/redis/commands/sets.rb#102
  def smove(source, destination, member); end

  # source://redis//lib/redis/commands/sets.rb#75
  def spop(key, count = T.unsafe(nil)); end

  # source://redis//lib/redis/commands/sets.rb#88
  def srandmember(key, count = T.unsafe(nil)); end

  # source://redis//lib/redis/commands/sets.rb#50
  def srem(key, member); end

  # source://redis//lib/redis/commands/sets.rb#66
  def srem?(key, member); end

  # source://redis//lib/redis/commands/sets.rb#196
  def sscan(key, cursor, **options); end

  # source://redis//lib/redis/commands/sets.rb#211
  def sscan_each(key, **options, &block); end

  # source://redis//lib/redis/commands/sets.rb#172
  def sunion(*keys); end

  # source://redis//lib/redis/commands/sets.rb#181
  def sunionstore(destination, *keys); end
end

# source://redis//lib/redis/commands/sorted_sets.rb#5
module Redis::Commands::SortedSets
  # source://redis//lib/redis/commands/sorted_sets.rb#181
  def bzpopmax(*args); end

  # source://redis//lib/redis/commands/sorted_sets.rb#202
  def bzpopmin(*args); end

  # source://redis//lib/redis/commands/sorted_sets.rb#53
  def zadd(key, *args, nx: T.unsafe(nil), xx: T.unsafe(nil), lt: T.unsafe(nil), gt: T.unsafe(nil), ch: T.unsafe(nil), incr: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/sorted_sets.rb#14
  def zcard(key); end

  # source://redis//lib/redis/commands/sorted_sets.rb#608
  def zcount(key, min, max); end

  # source://redis//lib/redis/commands/sorted_sets.rb#717
  def zdiff(*keys, with_scores: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/sorted_sets.rb#733
  def zdiffstore(*args, **_arg1); end

  # source://redis//lib/redis/commands/sorted_sets.rb#86
  def zincrby(key, increment, member); end

  # source://redis//lib/redis/commands/sorted_sets.rb#631
  def zinter(*args, **_arg1); end

  # source://redis//lib/redis/commands/sorted_sets.rb#650
  def zinterstore(*args, **_arg1); end

  # source://redis//lib/redis/commands/sorted_sets.rb#439
  def zlexcount(key, min, max); end

  # source://redis//lib/redis/commands/sorted_sets.rb#230
  def zmscore(key, *members); end

  # source://redis//lib/redis/commands/sorted_sets.rb#138
  def zpopmax(key, count = T.unsafe(nil)); end

  # source://redis//lib/redis/commands/sorted_sets.rb#159
  def zpopmin(key, count = T.unsafe(nil)); end

  # source://redis//lib/redis/commands/sorted_sets.rb#258
  def zrandmember(key, count = T.unsafe(nil), withscores: T.unsafe(nil), with_scores: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/sorted_sets.rb#297
  def zrange(key, start, stop, byscore: T.unsafe(nil), by_score: T.unsafe(nil), bylex: T.unsafe(nil), by_lex: T.unsafe(nil), rev: T.unsafe(nil), limit: T.unsafe(nil), withscores: T.unsafe(nil), with_scores: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/sorted_sets.rb#464
  def zrangebylex(key, min, max, limit: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/sorted_sets.rb#524
  def zrangebyscore(key, min, max, withscores: T.unsafe(nil), with_scores: T.unsafe(nil), limit: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/sorted_sets.rb#339
  def zrangestore(dest_key, src_key, start, stop, byscore: T.unsafe(nil), by_score: T.unsafe(nil), bylex: T.unsafe(nil), by_lex: T.unsafe(nil), rev: T.unsafe(nil), limit: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/sorted_sets.rb#390
  def zrank(key, member); end

  # source://redis//lib/redis/commands/sorted_sets.rb#107
  def zrem(key, member); end

  # source://redis//lib/redis/commands/sorted_sets.rb#417
  def zremrangebyrank(key, start, stop); end

  # source://redis//lib/redis/commands/sorted_sets.rb#587
  def zremrangebyscore(key, min, max); end

  # source://redis//lib/redis/commands/sorted_sets.rb#374
  def zrevrange(key, start, stop, withscores: T.unsafe(nil), with_scores: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/sorted_sets.rb#486
  def zrevrangebylex(key, max, min, limit: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/sorted_sets.rb#554
  def zrevrangebyscore(key, max, min, withscores: T.unsafe(nil), with_scores: T.unsafe(nil), limit: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/sorted_sets.rb#400
  def zrevrank(key, member); end

  # source://redis//lib/redis/commands/sorted_sets.rb#750
  def zscan(key, cursor, **options); end

  # source://redis//lib/redis/commands/sorted_sets.rb#767
  def zscan_each(key, **options, &block); end

  # source://redis//lib/redis/commands/sorted_sets.rb#217
  def zscore(key, member); end

  # source://redis//lib/redis/commands/sorted_sets.rb#674
  def zunion(*args, **_arg1); end

  # source://redis//lib/redis/commands/sorted_sets.rb#692
  def zunionstore(*args, **_arg1); end

  private

  # source://redis//lib/redis/commands/sorted_sets.rb#780
  def _zsets_operation(cmd, *keys, weights: T.unsafe(nil), aggregate: T.unsafe(nil), with_scores: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/sorted_sets.rb#798
  def _zsets_operation_store(cmd, destination, keys, weights: T.unsafe(nil), aggregate: T.unsafe(nil)); end
end

# source://redis//lib/redis/commands/streams.rb#5
module Redis::Commands::Streams
  # source://redis//lib/redis/commands/streams.rb#251
  def xack(key, group, *ids); end

  # source://redis//lib/redis/commands/streams.rb#51
  def xadd(key, entry, approximate: T.unsafe(nil), maxlen: T.unsafe(nil), id: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/streams.rb#321
  def xautoclaim(key, group, consumer, min_idle_time, start, count: T.unsafe(nil), justid: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/streams.rb#288
  def xclaim(key, group, consumer, min_idle_time, *ids, **opts); end

  # source://redis//lib/redis/commands/streams.rb#91
  def xdel(key, *ids); end

  # source://redis//lib/redis/commands/streams.rb#199
  def xgroup(subcommand, key, group, id_or_consumer = T.unsafe(nil), mkstream: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/streams.rb#22
  def xinfo(subcommand, key, group = T.unsafe(nil)); end

  # source://redis//lib/redis/commands/streams.rb#150
  def xlen(key); end

  # source://redis//lib/redis/commands/streams.rb#349
  def xpending(key, group, *args); end

  # source://redis//lib/redis/commands/streams.rb#113
  def xrange(key, start = T.unsafe(nil), range_end = T.unsafe(nil), count: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/streams.rb#171
  def xread(keys, ids, count: T.unsafe(nil), block: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/streams.rb#229
  def xreadgroup(group, consumer, keys, ids, count: T.unsafe(nil), block: T.unsafe(nil), noack: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/streams.rb#136
  def xrevrange(key, range_end = T.unsafe(nil), start = T.unsafe(nil), count: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/streams.rb#75
  def xtrim(key, maxlen, approximate: T.unsafe(nil)); end

  private

  # source://redis//lib/redis/commands/streams.rb#365
  def _xread(args, keys, ids, blocking_timeout_msec); end
end

# source://redis//lib/redis/commands/strings.rb#5
module Redis::Commands::Strings
  # source://redis//lib/redis/commands/strings.rb#254
  def append(key, value); end

  # source://redis//lib/redis/commands/strings.rb#14
  def decr(key); end

  # source://redis//lib/redis/commands/strings.rb#27
  def decrby(key, decrement); end

  # source://redis//lib/redis/commands/strings.rb#190
  def get(key); end

  # source://redis//lib/redis/commands/strings.rb#274
  def getdel(key); end

  # source://redis//lib/redis/commands/strings.rb#292
  def getex(key, ex: T.unsafe(nil), px: T.unsafe(nil), exat: T.unsafe(nil), pxat: T.unsafe(nil), persist: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/strings.rb#245
  def getrange(key, start, stop); end

  # source://redis//lib/redis/commands/strings.rb#264
  def getset(key, value); end

  # source://redis//lib/redis/commands/strings.rb#39
  def incr(key); end

  # source://redis//lib/redis/commands/strings.rb#52
  def incrby(key, increment); end

  # source://redis//lib/redis/commands/strings.rb#65
  def incrbyfloat(key, increment); end

  # source://redis//lib/redis/commands/strings.rb#218
  def mapped_mget(*keys); end

  # source://redis//lib/redis/commands/strings.rb#154
  def mapped_mset(hash); end

  # source://redis//lib/redis/commands/strings.rb#182
  def mapped_msetnx(hash); end

  # source://redis//lib/redis/commands/strings.rb#204
  def mget(*keys, &blk); end

  # source://redis//lib/redis/commands/strings.rb#140
  def mset(*args); end

  # source://redis//lib/redis/commands/strings.rb#168
  def msetnx(*args); end

  # source://redis//lib/redis/commands/strings.rb#117
  def psetex(key, ttl, value); end

  # source://redis//lib/redis/commands/strings.rb#83
  def set(key, value, ex: T.unsafe(nil), px: T.unsafe(nil), exat: T.unsafe(nil), pxat: T.unsafe(nil), nx: T.unsafe(nil), xx: T.unsafe(nil), keepttl: T.unsafe(nil), get: T.unsafe(nil)); end

  # source://redis//lib/redis/commands/strings.rb#107
  def setex(key, ttl, value); end

  # source://redis//lib/redis/commands/strings.rb#126
  def setnx(key, value); end

  # source://redis//lib/redis/commands/strings.rb#234
  def setrange(key, offset, value); end

  # source://redis//lib/redis/commands/strings.rb#308
  def strlen(key); end
end

# source://redis//lib/redis/commands/transactions.rb#5
module Redis::Commands::Transactions
  # source://redis//lib/redis/commands/transactions.rb#134
  def discard; end

  # source://redis//lib/redis/commands/transactions.rb#122
  def exec; end

  # source://redis//lib/redis/commands/transactions.rb#36
  def multi(&block); end

  # source://redis//lib/redis/commands/transactions.rb#108
  def unwatch; end

  # source://redis//lib/redis/commands/transactions.rb#83
  def watch(*keys); end
end

# source://redis//lib/redis/connection/registry.rb#4
module Redis::Connection
  class << self
    # source://redis//lib/redis/connection/registry.rb#9
    def drivers; end
  end
end

# source://redis//lib/redis/connection/command_helper.rb#5
module Redis::Connection::CommandHelper
  # source://redis//lib/redis/connection/command_helper.rb#8
  def build_command(args); end

  protected

  # source://redis//lib/redis/connection/command_helper.rb#36
  def encode(string); end
end

# source://redis//lib/redis/connection/command_helper.rb#6
Redis::Connection::CommandHelper::COMMAND_DELIMITER = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/connection/ruby.rb#291
class Redis::Connection::Ruby
  include ::Redis::Connection::CommandHelper

  # source://redis//lib/redis/connection/ruby.rb#354
  def initialize(sock); end

  # source://redis//lib/redis/connection/ruby.rb#358
  def connected?; end

  # source://redis//lib/redis/connection/ruby.rb#362
  def disconnect; end

  # source://redis//lib/redis/connection/ruby.rb#418
  def format_bulk_reply(line); end

  # source://redis//lib/redis/connection/ruby.rb#406
  def format_error_reply(line); end

  # source://redis//lib/redis/connection/ruby.rb#414
  def format_integer_reply(line); end

  # source://redis//lib/redis/connection/ruby.rb#427
  def format_multi_bulk_reply(line); end

  # source://redis//lib/redis/connection/ruby.rb#395
  def format_reply(reply_type, line); end

  # source://redis//lib/redis/connection/ruby.rb#410
  def format_status_reply(line); end

  # source://redis//lib/redis/connection/ruby.rb#339
  def get_tcp_keepalive; end

  # source://redis//lib/redis/connection/ruby.rb#381
  def read; end

  # source://redis//lib/redis/connection/ruby.rb#337
  def set_tcp_keepalive(keepalive); end

  # source://redis//lib/redis/connection/ruby.rb#347
  def set_tcp_nodelay; end

  # source://redis//lib/redis/connection/ruby.rb#369
  def timeout=(timeout); end

  # source://redis//lib/redis/connection/ruby.rb#377
  def write(command); end

  # source://redis//lib/redis/connection/ruby.rb#373
  def write_timeout=(timeout); end

  class << self
    # source://redis//lib/redis/connection/ruby.rb#300
    def connect(config); end
  end
end

# source://redis//lib/redis/connection/ruby.rb#298
Redis::Connection::Ruby::ASTERISK = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/connection/ruby.rb#296
Redis::Connection::Ruby::COLON = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/connection/ruby.rb#297
Redis::Connection::Ruby::DOLLAR = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/connection/ruby.rb#294
Redis::Connection::Ruby::MINUS = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/connection/ruby.rb#295
Redis::Connection::Ruby::PLUS = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/connection/ruby.rb#230
class Redis::Connection::SSLSocket < ::OpenSSL::SSL::SSLSocket
  include ::Redis::Connection::SocketMixin

  # source://redis//lib/redis/connection/ruby.rb#234
  def wait_readable(timeout = T.unsafe(nil)); end

  # source://redis//lib/redis/connection/ruby.rb#240
  def wait_writable(timeout = T.unsafe(nil)); end

  class << self
    # source://redis//lib/redis/connection/ruby.rb#245
    def connect(host, port, timeout, ssl_params); end
  end
end

# source://redis//lib/redis/connection/ruby.rb#18
module Redis::Connection::SocketMixin
  # source://redis//lib/redis/connection/ruby.rb#21
  def initialize(*args); end

  # source://redis//lib/redis/connection/ruby.rb#53
  def _read_from_socket(nbytes, buffer = T.unsafe(nil)); end

  # source://redis//lib/redis/connection/ruby.rb#45
  def gets; end

  # source://redis//lib/redis/connection/ruby.rb#36
  def read(nbytes); end

  # source://redis//lib/redis/connection/ruby.rb#28
  def timeout=(timeout); end

  # source://redis//lib/redis/connection/ruby.rb#72
  def write(buffer); end

  # source://redis//lib/redis/connection/ruby.rb#32
  def write_timeout=(timeout); end
end

# source://redis//lib/redis/connection/ruby.rb#19
Redis::Connection::SocketMixin::CRLF = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/connection/ruby.rb#150
class Redis::Connection::TCPSocket < ::Socket
  include ::Redis::Connection::SocketMixin

  class << self
    # source://redis//lib/redis/connection/ruby.rb#171
    def connect(host, port, timeout); end

    # source://redis//lib/redis/connection/ruby.rb#153
    def connect_addrinfo(addrinfo, port, timeout); end
  end
end

# source://redis//lib/redis/connection/ruby.rb#205
class Redis::Connection::UNIXSocket < ::Socket
  include ::Redis::Connection::SocketMixin

  class << self
    # source://redis//lib/redis/connection/ruby.rb#208
    def connect(path, timeout); end
  end
end

# source://redis//lib/redis/errors.rb#32
class Redis::ConnectionError < ::Redis::BaseConnectionError; end

# source://redis//lib/redis.rb#12
class Redis::Deprecated < ::StandardError; end

# source://redis//lib/redis/pipeline.rb#223
class Redis::DeprecatedMulti
  # source://redis//lib/redis/pipeline.rb#224
  def initialize(pipeline); end

  # source://redis//lib/redis/pipeline.rb#229
  def __getobj__; end
end

# source://redis//lib/redis/pipeline.rb#208
class Redis::DeprecatedPipeline
  # source://redis//lib/redis/pipeline.rb#209
  def initialize(pipeline); end

  # source://redis//lib/redis/pipeline.rb#214
  def __getobj__; end
end

# source://redis//lib/redis/distributed.rb#6
class Redis::Distributed
  # source://redis//lib/redis/distributed.rb#20
  def initialize(node_configs, options = T.unsafe(nil)); end

  # source://redis//lib/redis/distributed.rb#396
  def [](key); end

  # source://redis//lib/redis/distributed.rb#400
  def []=(key, value); end

  # source://redis//lib/redis/distributed.rb#462
  def _bpop(cmd, args); end

  # source://redis//lib/redis/distributed.rb#979
  def _eval(cmd, args); end

  # source://redis//lib/redis/distributed.rb#41
  def add_node(options); end

  # source://redis//lib/redis/distributed.rb#365
  def append(key, value); end

  # source://redis//lib/redis/distributed.rb#68
  def bgsave; end

  # source://redis//lib/redis/distributed.rb#370
  def bitcount(key, start = T.unsafe(nil), stop = T.unsafe(nil)); end

  # source://redis//lib/redis/distributed.rb#375
  def bitop(operation, destkey, *keys); end

  # source://redis//lib/redis/distributed.rb#382
  def bitpos(key, bit, start = T.unsafe(nil), stop = T.unsafe(nil)); end

  # source://redis//lib/redis/distributed.rb#418
  def blmove(source, destination, where_source, where_destination, timeout: T.unsafe(nil)); end

  # source://redis//lib/redis/distributed.rb#489
  def blpop(*args); end

  # source://redis//lib/redis/distributed.rb#495
  def brpop(*args); end

  # source://redis//lib/redis/distributed.rb#501
  def brpoplpush(source, destination, deprecated_timeout = T.unsafe(nil), **options); end

  # source://redis//lib/redis/distributed.rb#215
  def copy(source, destination, **options); end

  # source://redis//lib/redis/distributed.rb#73
  def dbsize; end

  # source://redis//lib/redis/distributed.rb#255
  def decr(key); end

  # source://redis//lib/redis/distributed.rb#260
  def decrby(key, decrement); end

  # source://redis//lib/redis/distributed.rb#163
  def del(*args); end

  # source://redis//lib/redis/distributed.rb#946
  def discard; end

  # source://redis//lib/redis/distributed.rb#148
  def dump(key); end

  # source://redis//lib/redis/distributed.rb#1006
  def dup; end

  # source://redis//lib/redis/distributed.rb#58
  def echo(value); end

  # source://redis//lib/redis/distributed.rb#993
  def eval(*args); end

  # source://redis//lib/redis/distributed.rb#998
  def evalsha(*args); end

  # source://redis//lib/redis/distributed.rb#937
  def exec; end

  # source://redis//lib/redis/distributed.rb#179
  def exists(*args); end

  # source://redis//lib/redis/distributed.rb#196
  def exists?(*args); end

  # source://redis//lib/redis/distributed.rb#118
  def expire(key, seconds, **kwargs); end

  # source://redis//lib/redis/distributed.rb#123
  def expireat(key, unix_time, **kwargs); end

  # source://redis//lib/redis/distributed.rb#78
  def flushall; end

  # source://redis//lib/redis/distributed.rb#83
  def flushdb; end

  # source://redis//lib/redis/distributed.rb#318
  def get(key); end

  # source://redis//lib/redis/distributed.rb#360
  def getbit(key, offset); end

  # source://redis//lib/redis/distributed.rb#323
  def getdel(key); end

  # source://redis//lib/redis/distributed.rb#328
  def getex(key, **options); end

  # source://redis//lib/redis/distributed.rb#350
  def getrange(key, start, stop); end

  # source://redis//lib/redis/distributed.rb#387
  def getset(key, value); end

  # source://redis//lib/redis/distributed.rb#826
  def hdel(key, *fields); end

  # source://redis//lib/redis/distributed.rb#831
  def hexists(key, field); end

  # source://redis//lib/redis/distributed.rb#808
  def hget(key, field); end

  # source://redis//lib/redis/distributed.rb#856
  def hgetall(key); end

  # source://redis//lib/redis/distributed.rb#836
  def hincrby(key, field, increment); end

  # source://redis//lib/redis/distributed.rb#841
  def hincrbyfloat(key, field, increment); end

  # source://redis//lib/redis/distributed.rb#846
  def hkeys(key); end

  # source://redis//lib/redis/distributed.rb#784
  def hlen(key); end

  # source://redis//lib/redis/distributed.rb#813
  def hmget(key, *fields); end

  # source://redis//lib/redis/distributed.rb#799
  def hmset(key, *attrs); end

  # source://redis//lib/redis/distributed.rb#821
  def hrandfield(key, count = T.unsafe(nil), **options); end

  # source://redis//lib/redis/distributed.rb#789
  def hset(key, *attrs); end

  # source://redis//lib/redis/distributed.rb#794
  def hsetnx(key, field, value); end

  # source://redis//lib/redis/distributed.rb#851
  def hvals(key); end

  # source://redis//lib/redis/distributed.rb#265
  def incr(key); end

  # source://redis//lib/redis/distributed.rb#270
  def incrby(key, increment); end

  # source://redis//lib/redis/distributed.rb#275
  def incrbyfloat(key, increment); end

  # source://redis//lib/redis/distributed.rb#88
  def info(cmd = T.unsafe(nil)); end

  # source://redis//lib/redis/distributed.rb#1002
  def inspect; end

  # source://redis//lib/redis/distributed.rb#205
  def keys(glob = T.unsafe(nil)); end

  # source://redis//lib/redis/distributed.rb#93
  def lastsave; end

  # source://redis//lib/redis/distributed.rb#508
  def lindex(key, index); end

  # source://redis//lib/redis/distributed.rb#513
  def linsert(key, where, pivot, value); end

  # source://redis//lib/redis/distributed.rb#405
  def llen(key); end

  # source://redis//lib/redis/distributed.rb#410
  def lmove(source, destination, where_source, where_destination); end

  # source://redis//lib/redis/distributed.rb#445
  def lpop(key, count = T.unsafe(nil)); end

  # source://redis//lib/redis/distributed.rb#425
  def lpush(key, value); end

  # source://redis//lib/redis/distributed.rb#430
  def lpushx(key, value); end

  # source://redis//lib/redis/distributed.rb#518
  def lrange(key, start, stop); end

  # source://redis//lib/redis/distributed.rb#523
  def lrem(key, count, value); end

  # source://redis//lib/redis/distributed.rb#528
  def lset(key, index, value); end

  # source://redis//lib/redis/distributed.rb#533
  def ltrim(key, start, stop); end

  # source://redis//lib/redis/distributed.rb#817
  def mapped_hmget(key, *fields); end

  # source://redis//lib/redis/distributed.rb#803
  def mapped_hmset(key, hash); end

  # source://redis//lib/redis/distributed.rb#338
  def mapped_mget(*keys); end

  # source://redis//lib/redis/distributed.rb#304
  def mapped_mset(_hash); end

  # source://redis//lib/redis/distributed.rb#313
  def mapped_msetnx(_hash); end

  # source://redis//lib/redis/distributed.rb#333
  def mget(*keys); end

  # source://redis//lib/redis/distributed.rb#158
  def migrate(_key, _options); end

  # source://redis//lib/redis/distributed.rb#98
  def monitor; end

  # source://redis//lib/redis/distributed.rb#210
  def move(key, db); end

  # source://redis//lib/redis/distributed.rb#300
  def mset(*_args); end

  # source://redis//lib/redis/distributed.rb#309
  def msetnx(*_args); end

  # source://redis//lib/redis/distributed.rb#928
  def multi(&block); end

  # source://redis//lib/redis/distributed.rb#30
  def node_for(key); end

  # source://redis//lib/redis/distributed.rb#37
  def nodes; end

  # source://redis//lib/redis/distributed.rb#113
  def persist(key); end

  # source://redis//lib/redis/distributed.rb#133
  def pexpire(key, milliseconds, **kwarg); end

  # source://redis//lib/redis/distributed.rb#138
  def pexpireat(key, ms_unix_time, **kwarg); end

  # source://redis//lib/redis/distributed.rb#960
  def pfadd(key, member); end

  # source://redis//lib/redis/distributed.rb#965
  def pfcount(*keys); end

  # source://redis//lib/redis/distributed.rb#973
  def pfmerge(dest_key, *source_key); end

  # source://redis//lib/redis/distributed.rb#53
  def ping; end

  # source://redis//lib/redis/distributed.rb#923
  def pipelined; end

  # source://redis//lib/redis/distributed.rb#290
  def psetex(key, ttl, value); end

  # source://redis//lib/redis/distributed.rb#890
  def psubscribe(*channels, &block); end

  # source://redis//lib/redis/distributed.rb#143
  def pttl(key); end

  # source://redis//lib/redis/distributed.rb#861
  def publish(channel, message); end

  # source://redis//lib/redis/distributed.rb#896
  def punsubscribe(*channels); end

  # source://redis//lib/redis/distributed.rb#63
  def quit; end

  # source://redis//lib/redis/distributed.rb#222
  def randomkey; end

  # source://redis//lib/redis/distributed.rb#227
  def rename(old_name, new_name); end

  # source://redis//lib/redis/distributed.rb#234
  def renamenx(old_name, new_name); end

  # source://redis//lib/redis/distributed.rb#153
  def restore(key, ttl, serialized_value, **options); end

  # source://redis//lib/redis/distributed.rb#18
  def ring; end

  # source://redis//lib/redis/distributed.rb#450
  def rpop(key, count = T.unsafe(nil)); end

  # source://redis//lib/redis/distributed.rb#456
  def rpoplpush(source, destination); end

  # source://redis//lib/redis/distributed.rb#435
  def rpush(key, value); end

  # source://redis//lib/redis/distributed.rb#440
  def rpushx(key, value); end

  # source://redis//lib/redis/distributed.rb#543
  def sadd(key, member); end

  # source://redis//lib/redis/distributed.rb#548
  def sadd?(key, member); end

  # source://redis//lib/redis/distributed.rb#103
  def save; end

  # source://redis//lib/redis/distributed.rb#538
  def scard(key); end

  # source://redis//lib/redis/distributed.rb#955
  def script(subcommand, *args); end

  # source://redis//lib/redis/distributed.rb#605
  def sdiff(*keys); end

  # source://redis//lib/redis/distributed.rb#612
  def sdiffstore(destination, *keys); end

  # source://redis//lib/redis/distributed.rb#48
  def select(db); end

  # source://redis//lib/redis/distributed.rb#280
  def set(key, value, **options); end

  # source://redis//lib/redis/distributed.rb#355
  def setbit(key, offset, value); end

  # source://redis//lib/redis/distributed.rb#285
  def setex(key, ttl, value); end

  # source://redis//lib/redis/distributed.rb#295
  def setnx(key, value); end

  # source://redis//lib/redis/distributed.rb#345
  def setrange(key, offset, value); end

  # source://redis//lib/redis/distributed.rb#619
  def sinter(*keys); end

  # source://redis//lib/redis/distributed.rb#626
  def sinterstore(destination, *keys); end

  # source://redis//lib/redis/distributed.rb#580
  def sismember(key, member); end

  # source://redis//lib/redis/distributed.rb#590
  def smembers(key); end

  # source://redis//lib/redis/distributed.rb#585
  def smismember(key, *members); end

  # source://redis//lib/redis/distributed.rb#573
  def smove(source, destination, member); end

  # source://redis//lib/redis/distributed.rb#241
  def sort(key, **options); end

  # source://redis//lib/redis/distributed.rb#563
  def spop(key, count = T.unsafe(nil)); end

  # source://redis//lib/redis/distributed.rb#568
  def srandmember(key, count = T.unsafe(nil)); end

  # source://redis//lib/redis/distributed.rb#553
  def srem(key, member); end

  # source://redis//lib/redis/distributed.rb#558
  def srem?(key, member); end

  # source://redis//lib/redis/distributed.rb#595
  def sscan(key, cursor, **options); end

  # source://redis//lib/redis/distributed.rb#600
  def sscan_each(key, **options, &block); end

  # source://redis//lib/redis/distributed.rb#392
  def strlen(key); end

  # source://redis//lib/redis/distributed.rb#870
  def subscribe(channel, *channels, &block); end

  # source://redis//lib/redis/distributed.rb#865
  def subscribed?; end

  # source://redis//lib/redis/distributed.rb#633
  def sunion(*keys); end

  # source://redis//lib/redis/distributed.rb#640
  def sunionstore(destination, *keys); end

  # source://redis//lib/redis/distributed.rb#108
  def time; end

  # source://redis//lib/redis/distributed.rb#128
  def ttl(key); end

  # source://redis//lib/redis/distributed.rb#250
  def type(key); end

  # source://redis//lib/redis/distributed.rb#171
  def unlink(*args); end

  # source://redis//lib/redis/distributed.rb#883
  def unsubscribe(*channels); end

  # source://redis//lib/redis/distributed.rb#915
  def unwatch; end

  # source://redis//lib/redis/distributed.rb#901
  def watch(*keys, &block); end

  # source://redis//lib/redis/distributed.rb#653
  def zadd(key, *args, **_arg2); end

  # source://redis//lib/redis/distributed.rb#647
  def zcard(key); end

  # source://redis//lib/redis/distributed.rb#735
  def zcount(key, min, max); end

  # source://redis//lib/redis/distributed.rb#769
  def zdiff(*keys, **options); end

  # source://redis//lib/redis/distributed.rb#777
  def zdiffstore(destination, keys, **options); end

  # source://redis//lib/redis/distributed.rb#659
  def zincrby(key, increment, member); end

  # source://redis//lib/redis/distributed.rb#740
  def zinter(*keys, **options); end

  # source://redis//lib/redis/distributed.rb#748
  def zinterstore(destination, keys, **options); end

  # source://redis//lib/redis/distributed.rb#679
  def zmscore(key, *members); end

  # source://redis//lib/redis/distributed.rb#674
  def zrandmember(key, count = T.unsafe(nil), **options); end

  # source://redis//lib/redis/distributed.rb#684
  def zrange(key, start, stop, **options); end

  # source://redis//lib/redis/distributed.rb#719
  def zrangebyscore(key, min, max, **options); end

  # source://redis//lib/redis/distributed.rb#690
  def zrangestore(dest_key, src_key, start, stop, **options); end

  # source://redis//lib/redis/distributed.rb#703
  def zrank(key, member); end

  # source://redis//lib/redis/distributed.rb#664
  def zrem(key, member); end

  # source://redis//lib/redis/distributed.rb#714
  def zremrangebyrank(key, start, stop); end

  # source://redis//lib/redis/distributed.rb#730
  def zremrangebyscore(key, min, max); end

  # source://redis//lib/redis/distributed.rb#698
  def zrevrange(key, start, stop, **options); end

  # source://redis//lib/redis/distributed.rb#725
  def zrevrangebyscore(key, max, min, **options); end

  # source://redis//lib/redis/distributed.rb#709
  def zrevrank(key, member); end

  # source://redis//lib/redis/distributed.rb#669
  def zscore(key, member); end

  # source://redis//lib/redis/distributed.rb#755
  def zunion(*keys, **options); end

  # source://redis//lib/redis/distributed.rb#762
  def zunionstore(destination, keys, **options); end

  protected

  # source://redis//lib/redis/distributed.rb#1026
  def ensure_same_node(command, keys); end

  # source://redis//lib/redis/distributed.rb#1022
  def key_tag(key); end

  # source://redis//lib/redis/distributed.rb#1018
  def node_index_for(key); end

  # source://redis//lib/redis/distributed.rb#1012
  def on_each_node(command, *args); end
end

# source://redis//lib/redis/distributed.rb#7
class Redis::Distributed::CannotDistribute < ::RuntimeError
  # source://redis//lib/redis/distributed.rb#8
  def initialize(command); end

  # source://redis//lib/redis/distributed.rb#12
  def message; end
end

# source://redis//lib/redis/pipeline.rb#244
class Redis::Future < ::BasicObject
  # source://redis//lib/redis/pipeline.rb#249
  def initialize(command, transformation, timeout); end

  # source://redis//lib/redis/pipeline.rb#256
  def ==(_other); end

  # source://redis//lib/redis/pipeline.rb#275
  def _command; end

  # source://redis//lib/redis/pipeline.rb#270
  def _set(object); end

  # source://redis//lib/redis/pipeline.rb#288
  def class; end

  # source://redis//lib/redis/pipeline.rb#266
  def inspect; end

  # source://redis//lib/redis/pipeline.rb#284
  def is_a?(other); end

  # source://redis//lib/redis/pipeline.rb#247
  def timeout; end

  # source://redis//lib/redis/pipeline.rb#279
  def value; end
end

# source://redis//lib/redis/pipeline.rb#245
Redis::Future::FutureNotReady = T.let(T.unsafe(nil), Redis::FutureNotReady)

# source://redis//lib/redis/pipeline.rb#238
class Redis::FutureNotReady < ::RuntimeError
  # source://redis//lib/redis/pipeline.rb#239
  def initialize; end
end

# source://redis//lib/redis/hash_ring.rb#6
class Redis::HashRing
  # source://redis//lib/redis/hash_ring.rb#14
  def initialize(nodes = T.unsafe(nil), replicas = T.unsafe(nil)); end

  # source://redis//lib/redis/hash_ring.rb#25
  def add_node(node); end

  # source://redis//lib/redis/hash_ring.rb#45
  def get_node(key); end

  # source://redis//lib/redis/hash_ring.rb#49
  def get_node_pos(key); end

  # source://redis//lib/redis/hash_ring.rb#57
  def iter_nodes(key); end

  # source://redis//lib/redis/hash_ring.rb#9
  def nodes; end

  # source://redis//lib/redis/hash_ring.rb#35
  def remove_node(node); end

  # source://redis//lib/redis/hash_ring.rb#9
  def replicas; end

  # source://redis//lib/redis/hash_ring.rb#9
  def ring; end

  # source://redis//lib/redis/hash_ring.rb#9
  def sorted_keys; end

  class << self
    # source://redis//lib/redis/hash_ring.rb#67
    def binary_search(ary, value); end
  end
end

# source://redis//lib/redis/hash_ring.rb#7
Redis::HashRing::POINTS_PER_SERVER = T.let(T.unsafe(nil), Integer)

# source://redis//lib/redis/errors.rb#40
class Redis::InheritedError < ::Redis::BaseConnectionError; end

# source://redis//lib/redis/errors.rb#44
class Redis::InvalidClientOptionError < ::Redis::BaseError; end

# source://redis//lib/redis/pipeline.rb#293
class Redis::MultiFuture < ::Redis::Future
  # source://redis//lib/redis/pipeline.rb#294
  def initialize(futures); end

  # source://redis//lib/redis/pipeline.rb#299
  def _set(replies); end
end

# source://redis//lib/redis/pipeline.rb#45
class Redis::Pipeline
  # source://redis//lib/redis/pipeline.rb#79
  def initialize(client); end

  # source://redis//lib/redis/pipeline.rb#106
  def call(command, timeout: T.unsafe(nil), &block); end

  # source://redis//lib/redis/pipeline.rb#119
  def call_pipeline(pipeline); end

  # source://redis//lib/redis/pipeline.rb#115
  def call_with_timeout(command, timeout, &block); end

  # source://redis//lib/redis/pipeline.rb#74
  def client; end

  # source://redis//lib/redis/pipeline.rb#126
  def commands; end

  # source://redis//lib/redis/pipeline.rb#73
  def db; end

  # source://redis//lib/redis/pipeline.rb#73
  def db=(_arg0); end

  # source://redis//lib/redis/pipeline.rb#102
  def empty?; end

  # source://redis//lib/redis/pipeline.rb#143
  def finish(replies, &blk); end

  # source://redis//lib/redis/pipeline.rb#76
  def futures; end

  # source://redis//lib/redis/pipeline.rb#76
  def materialized_futures; end

  # source://redis//lib/redis/pipeline.rb#98
  def shutdown?; end

  # source://redis//lib/redis/pipeline.rb#86
  def timeout; end

  # source://redis//lib/redis/pipeline.rb#130
  def timeouts; end

  # source://redis//lib/redis/pipeline.rb#134
  def with_reconnect(val = T.unsafe(nil)); end

  # source://redis//lib/redis/pipeline.rb#90
  def with_reconnect?; end

  # source://redis//lib/redis/pipeline.rb#139
  def without_reconnect(&blk); end

  # source://redis//lib/redis/pipeline.rb#94
  def without_reconnect?; end

  class << self
    # source://redis//lib/redis/pipeline.rb#52
    def deprecation_warning(method, caller_locations); end
  end
end

# source://redis//lib/redis/pipeline.rb#155
class Redis::Pipeline::Multi < ::Redis::Pipeline
  # source://redis//lib/redis/pipeline.rb#198
  def commands; end

  # source://redis//lib/redis/pipeline.rb#156
  def finish(replies); end

  # source://redis//lib/redis/pipeline.rb#178
  def materialized_futures; end

  # source://redis//lib/redis/pipeline.rb#190
  def timeouts; end
end

# source://redis//lib/redis/pipeline.rb#46
Redis::Pipeline::REDIS_INTERNAL_PATH = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/pipeline.rb#49
Redis::Pipeline::STDLIB_PATH = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/pipeline.rb#6
class Redis::PipelinedConnection
  include ::Redis::Commands::Bitmaps
  include ::Redis::Commands::Cluster
  include ::Redis::Commands::Connection
  include ::Redis::Commands::Geo
  include ::Redis::Commands::Hashes
  include ::Redis::Commands::HyperLogLog
  include ::Redis::Commands::Keys
  include ::Redis::Commands::Lists
  include ::Redis::Commands::Pubsub
  include ::Redis::Commands::Scripting
  include ::Redis::Commands::Server
  include ::Redis::Commands::Sets
  include ::Redis::Commands::SortedSets
  include ::Redis::Commands::Streams
  include ::Redis::Commands::Strings
  include ::Redis::Commands::Transactions
  include ::Redis::Commands

  # source://redis//lib/redis/pipeline.rb#7
  def initialize(pipeline); end

  # source://redis//lib/redis/pipeline.rb#25
  def call_pipeline(pipeline); end

  # source://redis//lib/redis/pipeline.rb#13
  def db; end

  # source://redis//lib/redis/pipeline.rb#17
  def db=(db); end

  # source://redis//lib/redis/pipeline.rb#21
  def pipelined; end

  private

  # source://redis//lib/redis/pipeline.rb#40
  def send_blocking_command(command, timeout, &block); end

  # source://redis//lib/redis/pipeline.rb#36
  def send_command(command, &block); end

  # source://redis//lib/redis/pipeline.rb#32
  def synchronize; end
end

# source://redis//lib/redis/errors.rb#9
class Redis::ProtocolError < ::Redis::BaseError
  # source://redis//lib/redis/errors.rb#10
  def initialize(reply_type); end
end

# source://redis//lib/redis/subscribe.rb#4
class Redis::SubscribedClient
  # source://redis//lib/redis/subscribe.rb#5
  def initialize(client); end

  # source://redis//lib/redis/subscribe.rb#9
  def call(command); end

  # source://redis//lib/redis/subscribe.rb#21
  def psubscribe(*channels, &block); end

  # source://redis//lib/redis/subscribe.rb#25
  def psubscribe_with_timeout(timeout, *channels, &block); end

  # source://redis//lib/redis/subscribe.rb#33
  def punsubscribe(*channels); end

  # source://redis//lib/redis/subscribe.rb#13
  def subscribe(*channels, &block); end

  # source://redis//lib/redis/subscribe.rb#17
  def subscribe_with_timeout(timeout, *channels, &block); end

  # source://redis//lib/redis/subscribe.rb#29
  def unsubscribe(*channels); end

  protected

  # source://redis//lib/redis/subscribe.rb#39
  def subscription(start, stop, channels, block, timeout = T.unsafe(nil)); end
end

# source://redis//lib/redis/subscribe.rb#55
class Redis::Subscription
  # source://redis//lib/redis/subscribe.rb#58
  def initialize; end

  # source://redis//lib/redis/subscribe.rb#56
  def callbacks; end

  # source://redis//lib/redis/subscribe.rb#74
  def message(&block); end

  # source://redis//lib/redis/subscribe.rb#86
  def pmessage(&block); end

  # source://redis//lib/redis/subscribe.rb#78
  def psubscribe(&block); end

  # source://redis//lib/redis/subscribe.rb#82
  def punsubscribe(&block); end

  # source://redis//lib/redis/subscribe.rb#66
  def subscribe(&block); end

  # source://redis//lib/redis/subscribe.rb#70
  def unsubscribe(&block); end
end

# source://redis//lib/redis/errors.rb#36
class Redis::TimeoutError < ::Redis::BaseConnectionError; end

# source://redis//lib/redis/version.rb#4
Redis::VERSION = T.let(T.unsafe(nil), String)
